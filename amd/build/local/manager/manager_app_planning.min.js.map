{"version":3,"file":"manager_app_planning.min.js","sources":["../../../src/local/manager/manager_app_planning.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Moves wrapping navigation items into a more menu.\n *\n * @module     mod_competvet/local/manager/manager_app_planning\n * @class      competvet\n * @copyright  2024 Bas Brands\n * @author     Bas Brands <bas@sonsbeekmedia.nl>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport CompetState from 'mod_competvet/local/competstate';\nimport Repository from 'mod_competvet/local/new-repository';\nimport './plannings';\nimport ModalSaveCancel from 'core/modal_save_cancel';\nimport {getString} from 'core/str';\nimport ModalEvents from 'core/modal_events';\n\n/*\n* A CRUD manager for data.\n*/\nclass Manager {\n\n    /**\n     * Constructor.\n     */\n    constructor() {\n        this.app = document.querySelector('[data-region=\"planning\"]');\n        this.cmId = this.app.dataset.cmId;\n        this.situationId = this.app.dataset.situationId;\n        this.dataset = this.app.region;\n        this.addEventListeners();\n        this.getData();\n    }\n\n    /**\n     * Get the data for this manager.\n     */\n    async getData() {\n        const response = await Repository.getPlannings(this.cmId);\n        if (!response) {\n            return;\n        }\n        CompetState.setData(response);\n    }\n\n    /**\n     * Add event listeners to the page.\n     * @return {void}\n     */\n    addEventListeners() {\n        document.addEventListener('click', (e) => {\n            let btn = e.target.closest('[data-action]');\n            if (btn) {\n                e.preventDefault();\n                this.actions(btn);\n            }\n        });\n        this.app.classList.add('jsenabled');\n    }\n\n    /**\n     * Actions.\n     * @param {object} btn The button that was clicked.\n     */\n    async actions(btn) {\n        if (btn.dataset.action === 'add') {\n            this.add(btn);\n        }\n        if (btn.dataset.action === 'edit') {\n            this.edit(btn);\n        }\n        if (btn.dataset.action === 'save') {\n            const result = await this.save();\n            if (result) {\n                this.stopEdit();\n            }\n        }\n        if (btn.dataset.action === 'delete') {\n            this.delete(btn);\n        }\n    }\n\n    /**\n     * Add a new planning or category by manipulating the state, for the state structure see the example data structure.\n     * @param {object} btn The button that was clicked.\n     */\n    add(btn) {\n        let state = CompetState.getData();\n        if (btn.dataset.type === 'planning') {\n            state.plannings.push({\n                id: 0,\n                situationid: this.situationId, // TODO set the correct situation id.\n                startdate: this.getSuggested('startdate'),\n                enddate: this.getSuggested('enddate'),\n                groupid: '',\n                session: this.getSuggested('session'),\n                edit: true,\n                groups: state.groups,\n                pauses: [],\n            });\n        }\n        if (btn.dataset.type === 'pause') {\n            const planningid = parseInt(btn.dataset.id);\n            const planning = state.plannings.find((element) => element.id === planningid);\n            planning.pauses.push({\n                id: 0,\n                planningid: planningid,\n                startdate: planning.startdate,\n                enddate: planning.enddate,\n                editpause: true,\n            });\n        }\n        CompetState.setData(state);\n    }\n\n    /**\n     * Delete a planning or category by manipulating the state, for the state structure see the example data structure.\n     * @param {object} btn The button that was clicked.\n     */\n    async delete(btn) {\n        let state = CompetState.getData();\n        if (btn.dataset.type === 'planning') {\n            const planning = state.plannings.find((element) => element.id === parseInt(btn.dataset.id));\n            const deletePlanning = () => {\n                state.plannings.find((element) => element.id === parseInt(btn.dataset.id)).deleted = true;\n                CompetState.setData(state);\n                this.save();\n            };\n            if (planning.hasuserdata) {\n                const modal = await ModalSaveCancel.create({\n                    title: getString('delete', 'mod_competvet'),\n                    body: getString('confirmplanningdelete', 'mod_competvet'),\n                });\n                modal.show();\n                modal.getRoot().on(ModalEvents.save, () => {\n                    deletePlanning();\n                });\n            } else {\n                deletePlanning();\n            }\n        }\n        if (btn.dataset.type === 'pause') {\n            const pauseid = parseInt(btn.dataset.id);\n            const pause = this.getPause(pauseid);\n            pause.deleted = true;\n            CompetState.setData(state);\n            this.save();\n        }\n    }\n\n    /**\n     * Edit a planning or category by manipulating the state, for the state structure see the example data structure.\n     * All fields in the button container row with data-fieldtype will be made editable.\n     * @param {object} btn The button that was clicked.\n     */\n    edit(btn) {\n        let state = CompetState.getData();\n        // Remove edit from all fields.\n        state.plannings.forEach((element) => {\n            element.edit = false;\n            element.pauses.forEach((pause) => {\n                pause.editpause = false;\n            });\n        });\n        if (btn.dataset.type === 'planning') {\n            let planning = state.plannings.find((element) => element.id === parseInt(btn.dataset.id));\n            planning.edit = true;\n        }\n        if (btn.dataset.type === 'pause') {\n            const pause = this.getPause(parseInt(btn.dataset.id));\n            if (pause) {\n                pause.editpause = true;\n            }\n        }\n        CompetState.setData(state);\n    }\n\n    /**\n     * Get the pause object from the state.\n     * @param {Int} id The id of the pause.\n     * @return {Object} The pause object.\n     */\n    getPause(id) {\n        const state = CompetState.getData();\n        for (const planning of state.plannings) {\n            if (planning.pauses) {\n                const pause = planning.pauses.find((element) => element.id === id);\n                if (pause) {\n                    return pause;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Stop editing, remove the edit flag from the state elements.\n     */\n    stopEdit() {\n        const state = CompetState.getData();\n        // Remove edit from all fields.\n        state.plannings.forEach((element) => {\n            element.edit = false;\n            element.pauses.forEach((pause) => {\n                pause.editpause = false;\n            });\n        });\n        CompetState.setData(state);\n    }\n\n    update() {\n        const state = CompetState.getData();\n        state.plannings.forEach((element) => {\n            element.haschanged = false;\n            if (element.edit) {\n                // Update the grid with the new values from the UI.\n                element.haschanged = true;\n                element.startdate = this.getValue('planitem', 'startdate', element.id);\n                element.enddate = this.getValue('planitem', 'enddate', element.id);\n                element.groupid = this.getValue('planitem', 'groupid', element.id);\n                if (element.groupid !== '') {\n                    element.groupname = element.groups.find((group) => group.id === parseInt(element.groupid)).name;\n                }\n                element.session = this.getValue('planitem', 'session', element.id);\n                // Set the error flag if startdate, enddate or groupid are empty.\n                if (element.startdate === '') {\n                    element.errorstartdate = true;\n                    element.error = true;\n                }\n                if (element.enddate === '') {\n                    element.errorenddate = true;\n                    element.error = true;\n                }\n                if (element.groupid === '') {\n                    element.errorgroupid = true;\n                    element.error = true;\n                }\n                if (element.startdate !== '' && element.enddate !== '' && element.groupid !== '') {\n                    element.error = false;\n                }\n                if (!element.session) {\n                    element.errorsession = true;\n                    element.error = true;\n                }\n            }\n            this.updatePauses(element);\n        });\n        CompetState.setData(state);\n    }\n\n    /**\n     * Update the pauses.\n     * @param {Object} element The element to update.\n     */\n    updatePauses(element) {\n        element.pauses.forEach((pause) => {\n            pause.haschanged = false;\n            if (pause.editpause) {\n                // Update the grid with the new values from the UI.\n                pause.haschanged = true;\n                pause.startdate = this.getValue('pauseitem', 'startdate', pause.id);\n                pause.enddate = this.getValue('pauseitem', 'enddate', pause.id);\n                // Set the error flag if startdate, enddate or groupid are empty.\n                // Get timestamp from iso date.\n                const startdate = new Date(pause.startdate).getTime();\n                const enddate = new Date(pause.enddate).getTime();\n                const elementstartdate = new Date(element.startdate).getTime();\n                const elementenddate = new Date(element.enddate).getTime();\n                if (startdate < elementstartdate) {\n                    pause.errorstartdate = true;\n                    pause.error = true;\n                }\n                if (enddate > elementenddate) {\n                    pause.errorenddate = true;\n                    pause.error = true;\n                }\n                if (pause.startdate === '') {\n                    pause.errorstartdate = true;\n                    pause.error = true;\n                }\n                if (pause.enddate === '') {\n                    pause.errorenddate = true;\n                    pause.error = true;\n                }\n                if (pause.startdate !== '' && pause.enddate !== '') {\n                    pause.error = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * Get the planning object structure.\n     */\n    get planningObjectKeys() {\n        return ['id', 'situationid', 'startdate', 'enddate', 'groupid', 'session', 'pauses', 'haschanged', 'deleted'];\n    }\n\n    /**\n     * Get the pause object structure.\n     * @return {Array} The pause object keys.\n     */\n    get pauseObjectKeys() {\n        return ['id', 'planningid', 'startdate', 'enddate', 'haschanged', 'deleted'];\n    }\n\n    /**\n     * Save the state to the server.\n     *\n     * @return {Bool} True if the state was saved.\n     */\n    async save() {\n        this.update();\n        const state = CompetState.getData();\n        // If any element has an error, do not save.\n        if (state.plannings.find((element) => element.error)) {\n            return false;\n        }\n        // If any pause has an error, do not save.\n        if (state.plannings.find((element) => element.pauses.find((pause) => pause.error))) {\n            return false;\n        }\n        const saveState = {\n            plannings: [],\n        };\n        if (state.plannings.length > 0) {\n            saveState.plannings = [...state.plannings];\n        }\n        saveState.plannings.forEach((element) => {\n            // Delete all foreign keys.\n            Object.keys(element).forEach((key) => {\n                if (!this.planningObjectKeys.includes(key)) {\n                    delete element[key];\n                }\n            });\n            element.pauses.forEach((pause) => {\n                Object.keys(pause).forEach((key) => {\n                    if (!this.pauseObjectKeys.includes(key)) {\n                        delete pause[key];\n                    }\n                });\n            });\n        });\n        const result = await Repository.savePlannings(saveState);\n        this.getData();\n        return result;\n    }\n\n    /**\n     * Get the field value from the UI.\n     * @param {String} element The element to get the value from.\n     * @param {String} property The element property.\n     * @param {String} id The element id.\n     * @return {String} The value of the element.\n     */\n    getValue(element, property, id) {\n        const domNode = this.app.querySelector(`[data-region=\"${element}\"][data-id=\"${id}\"] [data-field=\"${property}\"]`);\n        if (!domNode) {\n            window.console.log(`Element not found: ${element} ${property} ${id}`);\n            const element = this.app.querySelector(`[data-region=\"${element}\"][data-id=\"${id}\"]`);\n            if (!element) {\n                window.console.log(`Element not found: ${element} ${id}`);\n                return '';\n            }\n        }\n        return domNode.value;\n    }\n\n    /**\n     * Get suggested values for the planning, based on the last planning.\n     *\n     * The startdate is the monday after the startdate of the last planning\n     * The enddate is the friday after the monday after the startdate of the last planning\n     * The session is the session of the last planning + 1, sessions need to be unique.\n     * @param {String} property The property to get the suggested value for.\n     * @return {String|Int} The suggested value.\n     */\n    getSuggested(property) {\n        const state = CompetState.getData();\n        let lastPlanning = state.plannings[state.plannings.length - 1];\n        let starttime = new Date().getTime();\n        let sessionDefault = 's';\n        if (lastPlanning) {\n            starttime = new Date(lastPlanning.enddate).getTime();\n        }\n\n        if (property === 'startdate') {\n            const date = new Date(starttime);\n            // Find the next monday.\n            date.setDate(date.getDate() + (1 + 7 - date.getDay()) % 7);\n           // Return in format yyyy-mm-ddThh:mm\n            return date.toISOString().slice(0, 16);\n        }\n        if (property === 'enddate') {\n            const date = new Date(starttime);\n            // Find the next monday.\n            date.setDate(date.getDate() + (1 + 7 - date.getDay()) % 7);\n            // Add 6 days.\n            date.setDate(date.getDate() + 6);\n            return date.toISOString().slice(0, 16);\n        }\n        if (property === 'session') {\n            // Check if this sessionname is unique.\n            const sessionnames = state.plannings.map((element) => element.session);\n            let counter = 1;\n            let session = sessionDefault + '-' + counter;\n            while (sessionnames.includes(session)) {\n                counter++;\n                session = sessionDefault + '-' + counter;\n            }\n            return session;\n        }\n        return '';\n    }\n}\n\n/*\n * Initialise\n *\n */\nconst init = () => {\n    new Manager();\n};\n\nexport default {\n    init: init,\n};"],"names":["Manager","constructor","app","document","querySelector","cmId","this","dataset","situationId","region","addEventListeners","getData","response","Repository","getPlannings","setData","addEventListener","e","btn","target","closest","preventDefault","actions","classList","add","action","edit","save","stopEdit","delete","state","CompetState","type","plannings","push","id","situationid","startdate","getSuggested","enddate","groupid","session","groups","pauses","planningid","parseInt","planning","find","element","editpause","deletePlanning","deleted","hasuserdata","modal","ModalSaveCancel","create","title","body","show","getRoot","on","ModalEvents","pauseid","getPause","forEach","pause","update","haschanged","getValue","groupname","group","name","errorstartdate","error","errorenddate","errorgroupid","errorsession","updatePauses","Date","getTime","elementstartdate","elementenddate","planningObjectKeys","pauseObjectKeys","saveState","length","Object","keys","key","includes","result","savePlannings","property","domNode","window","console","log","value","lastPlanning","starttime","date","setDate","getDate","getDay","toISOString","slice","sessionnames","map","counter","sessionDefault","init"],"mappings":";;;;;;;;;qTAmCMA,QAKFC,mBACSC,IAAMC,SAASC,cAAc,iCAC7BC,KAAOC,KAAKJ,IAAIK,QAAQF,UACxBG,YAAcF,KAAKJ,IAAIK,QAAQC,iBAC/BD,QAAUD,KAAKJ,IAAIO,YACnBC,yBACAC,gCAOCC,eAAiBC,uBAAWC,aAAaR,KAAKD,MAC/CO,+BAGOG,QAAQH,UAOxBF,oBACIP,SAASa,iBAAiB,SAAUC,QAC5BC,IAAMD,EAAEE,OAAOC,QAAQ,iBACvBF,MACAD,EAAEI,sBACGC,QAAQJ,cAGhBhB,IAAIqB,UAAUC,IAAI,2BAObN,QACiB,QAAvBA,IAAIX,QAAQkB,aACPD,IAAIN,KAEc,SAAvBA,IAAIX,QAAQkB,aACPC,KAAKR,KAEa,SAAvBA,IAAIX,QAAQkB,OAAmB,OACVnB,KAAKqB,aAEjBC,WAGc,WAAvBV,IAAIX,QAAQkB,aACPI,OAAOX,KAQpBM,IAAIN,SACIY,MAAQC,qBAAYpB,aACC,aAArBO,IAAIX,QAAQyB,MACZF,MAAMG,UAAUC,KAAK,CACjBC,GAAI,EACJC,YAAa9B,KAAKE,YAClB6B,UAAW/B,KAAKgC,aAAa,aAC7BC,QAASjC,KAAKgC,aAAa,WAC3BE,QAAS,GACTC,QAASnC,KAAKgC,aAAa,WAC3BZ,MAAM,EACNgB,OAAQZ,MAAMY,OACdC,OAAQ,KAGS,UAArBzB,IAAIX,QAAQyB,KAAkB,OACxBY,WAAaC,SAAS3B,IAAIX,QAAQ4B,IAClCW,SAAWhB,MAAMG,UAAUc,MAAMC,SAAYA,QAAQb,KAAOS,aAClEE,SAASH,OAAOT,KAAK,CACjBC,GAAI,EACJS,WAAYA,WACZP,UAAWS,SAAST,UACpBE,QAASO,SAASP,QAClBU,WAAW,yBAGPlC,QAAQe,oBAOXZ,SACLY,MAAQC,qBAAYpB,aACC,aAArBO,IAAIX,QAAQyB,KAAqB,OAC3Bc,SAAWhB,MAAMG,UAAUc,MAAMC,SAAYA,QAAQb,KAAOU,SAAS3B,IAAIX,QAAQ4B,MACjFe,eAAiB,KACnBpB,MAAMG,UAAUc,MAAMC,SAAYA,QAAQb,KAAOU,SAAS3B,IAAIX,QAAQ4B,MAAKgB,SAAU,uBACzEpC,QAAQe,YACfH,WAELmB,SAASM,YAAa,OAChBC,YAAcC,2BAAgBC,OAAO,CACvCC,OAAO,kBAAU,SAAU,iBAC3BC,MAAM,kBAAU,wBAAyB,mBAE7CJ,MAAMK,OACNL,MAAMM,UAAUC,GAAGC,sBAAYlC,MAAM,KACjCuB,yBAGJA,oBAGiB,UAArBhC,IAAIX,QAAQyB,KAAkB,OACxB8B,QAAUjB,SAAS3B,IAAIX,QAAQ4B,IACvB7B,KAAKyD,SAASD,SACtBX,SAAU,uBACJpC,QAAQe,YACfH,QASbD,KAAKR,SACGY,MAAQC,qBAAYpB,aAExBmB,MAAMG,UAAU+B,SAAShB,UACrBA,QAAQtB,MAAO,EACfsB,QAAQL,OAAOqB,SAASC,QACpBA,MAAMhB,WAAY,QAGD,aAArB/B,IAAIX,QAAQyB,KAAqB,CAClBF,MAAMG,UAAUc,MAAMC,SAAYA,QAAQb,KAAOU,SAAS3B,IAAIX,QAAQ4B,MAC5ET,MAAO,KAEK,UAArBR,IAAIX,QAAQyB,KAAkB,OACxBiC,MAAQ3D,KAAKyD,SAASlB,SAAS3B,IAAIX,QAAQ4B,KAC7C8B,QACAA,MAAMhB,WAAY,wBAGdlC,QAAQe,OAQxBiC,SAAS5B,UACCL,MAAQC,qBAAYpB,cACrB,MAAMmC,YAAYhB,MAAMG,aACrBa,SAASH,OAAQ,OACXsB,MAAQnB,SAASH,OAAOI,MAAMC,SAAYA,QAAQb,KAAOA,QAC3D8B,aACOA,aAIZ,KAMXrC,iBACUE,MAAQC,qBAAYpB,UAE1BmB,MAAMG,UAAU+B,SAAShB,UACrBA,QAAQtB,MAAO,EACfsB,QAAQL,OAAOqB,SAASC,QACpBA,MAAMhB,WAAY,6BAGdlC,QAAQe,OAGxBoC,eACUpC,MAAQC,qBAAYpB,UAC1BmB,MAAMG,UAAU+B,SAAShB,UACrBA,QAAQmB,YAAa,EACjBnB,QAAQtB,OAERsB,QAAQmB,YAAa,EACrBnB,QAAQX,UAAY/B,KAAK8D,SAAS,WAAY,YAAapB,QAAQb,IACnEa,QAAQT,QAAUjC,KAAK8D,SAAS,WAAY,UAAWpB,QAAQb,IAC/Da,QAAQR,QAAUlC,KAAK8D,SAAS,WAAY,UAAWpB,QAAQb,IACvC,KAApBa,QAAQR,UACRQ,QAAQqB,UAAYrB,QAAQN,OAAOK,MAAMuB,OAAUA,MAAMnC,KAAOU,SAASG,QAAQR,WAAU+B,MAE/FvB,QAAQP,QAAUnC,KAAK8D,SAAS,WAAY,UAAWpB,QAAQb,IAErC,KAAtBa,QAAQX,YACRW,QAAQwB,gBAAiB,EACzBxB,QAAQyB,OAAQ,GAEI,KAApBzB,QAAQT,UACRS,QAAQ0B,cAAe,EACvB1B,QAAQyB,OAAQ,GAEI,KAApBzB,QAAQR,UACRQ,QAAQ2B,cAAe,EACvB3B,QAAQyB,OAAQ,GAEM,KAAtBzB,QAAQX,WAAwC,KAApBW,QAAQT,SAAsC,KAApBS,QAAQR,UAC9DQ,QAAQyB,OAAQ,GAEfzB,QAAQP,UACTO,QAAQ4B,cAAe,EACvB5B,QAAQyB,OAAQ,SAGnBI,aAAa7B,iCAEVjC,QAAQe,OAOxB+C,aAAa7B,SACTA,QAAQL,OAAOqB,SAASC,WACpBA,MAAME,YAAa,EACfF,MAAMhB,UAAW,CAEjBgB,MAAME,YAAa,EACnBF,MAAM5B,UAAY/B,KAAK8D,SAAS,YAAa,YAAaH,MAAM9B,IAChE8B,MAAM1B,QAAUjC,KAAK8D,SAAS,YAAa,UAAWH,MAAM9B,UAGtDE,UAAY,IAAIyC,KAAKb,MAAM5B,WAAW0C,UACtCxC,QAAU,IAAIuC,KAAKb,MAAM1B,SAASwC,UAClCC,iBAAmB,IAAIF,KAAK9B,QAAQX,WAAW0C,UAC/CE,eAAiB,IAAIH,KAAK9B,QAAQT,SAASwC,UAC7C1C,UAAY2C,mBACZf,MAAMO,gBAAiB,EACvBP,MAAMQ,OAAQ,GAEdlC,QAAU0C,iBACVhB,MAAMS,cAAe,EACrBT,MAAMQ,OAAQ,GAEM,KAApBR,MAAM5B,YACN4B,MAAMO,gBAAiB,EACvBP,MAAMQ,OAAQ,GAEI,KAAlBR,MAAM1B,UACN0B,MAAMS,cAAe,EACrBT,MAAMQ,OAAQ,GAEM,KAApBR,MAAM5B,WAAsC,KAAlB4B,MAAM1B,UAChC0B,MAAMQ,OAAQ,OAS1BS,+BACO,CAAC,KAAM,cAAe,YAAa,UAAW,UAAW,UAAW,SAAU,aAAc,WAOnGC,4BACO,CAAC,KAAM,aAAc,YAAa,UAAW,aAAc,6BAS7DjB,eACCpC,MAAQC,qBAAYpB,aAEtBmB,MAAMG,UAAUc,MAAMC,SAAYA,QAAQyB,eACnC,KAGP3C,MAAMG,UAAUc,MAAMC,SAAYA,QAAQL,OAAOI,MAAMkB,OAAUA,MAAMQ,iBAChE,QAELW,UAAY,CACdnD,UAAW,IAEXH,MAAMG,UAAUoD,OAAS,IACzBD,UAAUnD,UAAY,IAAIH,MAAMG,YAEpCmD,UAAUnD,UAAU+B,SAAShB,UAEzBsC,OAAOC,KAAKvC,SAASgB,SAASwB,MACrBlF,KAAK4E,mBAAmBO,SAASD,aAC3BxC,QAAQwC,QAGvBxC,QAAQL,OAAOqB,SAASC,QACpBqB,OAAOC,KAAKtB,OAAOD,SAASwB,MACnBlF,KAAK6E,gBAAgBM,SAASD,aACxBvB,MAAMuB,oBAKvBE,aAAe7E,uBAAW8E,cAAcP,uBACzCzE,UACE+E,OAUXtB,SAASpB,QAAS4C,SAAUzD,UAClB0D,QAAUvF,KAAKJ,IAAIE,sCAA+B4C,+BAAsBb,8BAAqByD,oBAC9FC,QAAS,CACVC,OAAOC,QAAQC,iCAA0BhD,oBAAW4C,qBAAYzD,WAC1Da,QAAU1C,KAAKJ,IAAIE,sCAA+B4C,+BAAsBb,cACzEa,eACD8C,OAAOC,QAAQC,iCAA0BhD,oBAAWb,KAC7C,UAGR0D,QAAQI,MAYnB3D,aAAasD,gBACH9D,MAAQC,qBAAYpB,cACtBuF,aAAepE,MAAMG,UAAUH,MAAMG,UAAUoD,OAAS,GACxDc,WAAY,IAAIrB,MAAOC,aAEvBmB,eACAC,UAAY,IAAIrB,KAAKoB,aAAa3D,SAASwC,WAG9B,cAAba,SAA0B,OACpBQ,KAAO,IAAItB,KAAKqB,kBAEtBC,KAAKC,QAAQD,KAAKE,WAAa,EAAQF,KAAKG,UAAY,GAEjDH,KAAKI,cAAcC,MAAM,EAAG,OAEtB,YAAbb,SAAwB,OAClBQ,KAAO,IAAItB,KAAKqB,kBAEtBC,KAAKC,QAAQD,KAAKE,WAAa,EAAQF,KAAKG,UAAY,GAExDH,KAAKC,QAAQD,KAAKE,UAAY,GACvBF,KAAKI,cAAcC,MAAM,EAAG,OAEtB,YAAbb,SAAwB,OAElBc,aAAe5E,MAAMG,UAAU0E,KAAK3D,SAAYA,QAAQP,cAC1DmE,QAAU,EACVnE,QAAUoE,KAAuBD,aAC9BF,aAAajB,SAAShD,UACzBmE,UACAnE,QAAUoE,KAAuBD,eAE9BnE,cAEJ,iBAYA,CACXqE,KALS,SACL9G"}